\documentclass{svproc}
\usepackage{url}
\tolerance=1
\emergencystretch=\maxdimen
\hyphenpenalty=10000
\usepackage{caption}
\usepackage{float}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{algorithmic}
\def\UrlFont{\rmfamily}

\begin{document}
\mainmatter
\title{Your Project Report Title Here
}
\subtitle{CS7IS2 Project (2019/2020)}
\author{Kulkarni Shravani Deepak, Kapoor Shuchita, Asolkar Jayprakash \and Chauhan Paritosh}

\institute{
\email{email\_address\_1}, (multiple email addresses separated by comma)}

\maketitle              % typeset the title of the contribution

\begin{abstract}
The abstract should summarize the contents of the report and should contain at least 70 and at most 150 words. It should be set in 9-point font size and should be inset 1.0 cm from the right and left margins. There should be two blank (10-point) lines before and after the abstract. This document is in the required format. The abstract should give a concise overview of the main points of the report: the motivation behind the work, a very high level description of the problem and how it was solved by the proposed algorithms. The abstract must not include any figures or table.
\keywords{computational geometry, graph theory, Hamilton cycles}
\end{abstract}
%

 

\section{Introduction}
There have been many heuristic searching algorithms in the AI domain. Many gaming problems have been formed to test their efficiency. The N-puzzle problem is among these problems, and it is also included in the list of classic difficulty problems. This puzzle consists of N square tiles with tiles numbered from 1 to N. The goal of this problem is to rearrange the numbers in ascending order on the MxM board. This paper focusses on the 8-puzzle problem, which is a smaller version of the N-puzzle problem, and finds solutions using four algorithms (BFS, DFS, A*).  Also, these solutions are compared by examing their evaluation metrics, such as the cost of the path and time taken to find the solution. \\

\noindent The paper is structured as follows: section 2 discusses prior literature outlining the algorithms used in those papers,  section 3 defines the 8-puzzle problem in detail and describes the algorithms used, section 4 shows the results and comparisons of these algorithms.

\section{Related Work}

According to the Pearl, et. Al. , the environment that provides a platform for the search is known as Problem Space. Each of these problem spaces consists a set of states and operators. For instance, in terms of 8 puzzle, states can be defined as the different possible arrangement from the initial configuration of the numbers while operators are the possible directions, i.e. Left, Right, Up or Down. The problem instance can be defined as the problem space that consists of initial state and the goal state with a solution. The solution in this case is defined as the set of operators that changes the state from initial to the goal state. To provide a perspective in terms of visualization, the problem space is considered as a graph (generally a tree) where each state is defined by the node and each operator is illustrated as an edge between the nodes.

In searching problem space, there are many methods than can be applied to get to the solution (goal state).We begin with BruteForce search methods which includes Breadth-First Search, Depth-First Search and depth-First Iterative Deepening. This will be followed by a deeper study on the Heuristic Search that includes methods like – A*, Iterative-Deepening  A*, Extended Breadth First Search Algorithm.
\subsection{Breadth First Search}
BFS is one of the Brute-Force Algorithms that do not require full knowledge of the State Space to arrive at the goal. This uninformed type of algorithm generates its own memory of the State Space by registering all the nodes that have been traversed in the search tree. For instance, the initial state in the 8-Puzzle problem is considered as the root node and offspring nodes are generated in such a way that the neighbouring bodes represent a single move or state change from the parent. This strategy employs the Breadth-First traversal approach similar from trees and graphs, were the adjacent neighbours are traversed to find the optimum state. The lower levels are generated and traversed only if the required state is not reached on the current level of the tree. This can be an evidence that BFS always provides an optimized solution for a problem. In terms of data structure, BFS uses FIFO (First in First out) principle for performing search. The time complexity in finding the optimum state is directly proportional to the size of the search space, i.e O(b \^d). Another disadvantage could be the space complexity, where large chunk of memory could be used as all the state must be stored in order to generate the next level in the tree.
\subsection{Depth First Search}
In comparison to BFS, where the vertical expansion of the state was the main aim to find the optimal solution, the DFS focuses on the horizontal expansion of one state.  The idea is to keep expanding the state till it reaches the optimal solution or backtracking to the next nearest possible state. The algorithm employs LIFO ( Last in First Out ) approach in order to search the desired state in the search space. The time complexity doesn’t change and remains same as in BFS O(b \^d), the only advantage of using this over BFS is in terms of space complexity, where only current search path is being saved (O(d) ).  This algorithm lacks in the ability to provide an optimal solution in the given time and hence sometime must be provided with an explicit cut-off depth. If the solution state is not reached before the cut-off, then we may never find that state , or the first found solution may not be an optimal one. 
To solve the 8-puzzle problem, we have chosen to implement Breadth-First Search, Depth-First Search, A* and Iterative Depth A* algorithms. With these selected algorithms we can compare both uninformed and informed search techniques in terms of completeness, space-time complexity, and optimality. Although the exhaustive traversal method of both breadth-first and depth-first searches do not promise optimality, they can act as a baseline for comparison with other algorithms in terms of improvements. Both A* and IDA algorithms make use of heuristics to make informed search traversal and provide an optimal solution. All these algorithms form the basis of solutions for various search problems in the domain of artificial intelligence.
While breadth-first search ensures completeness of searching the entire space of available states, it consumes a lot of memory for its implementation. Conversely, depth-first search uses less memory space as it stores only one branch of the search tree in memory at any given time, but the tree search version lacks completeness due to possible infinite loops[1]. With an evaluation function that combines both the cost to reach the current state and estimated cost to reach the goal from the current state, the A* algorithm is both optimal and complete. Our intention to select the above algorithms is to evaluate the performance of these basic search algorithms on a real-world AI problem such as the 8-puzzle and compare various aspects of the algorithms.
\subsection{Depth First Iterative Deepening}
This algorithm concatenates the advantages of both BFS and DFS. The basic idea is to run DFS on each level and increase the DFS depth cut-off by one after generating all states on a level of the tree. This ensures to provide the optimal solution to the problem and keeps the space complexity on check as it must only store the current branch that is under investigation (O(d))
\subsection{Bidirectional Search}
In this Algorithm, the problem space has additional requirement of a specific goal state than a criteria along with the initial state. The motive is to run BFS on the both the states and find a common child state that can be concatenated to form a solution. Some of the challenges on using this algorithm are that  operators for the problem space must be invertible or there must be a feasibility of back chaining in order to reverse the path from the common state to the target state. The space and time complexity of this algorithm is O(b \^(d/2)).

\subsection{Informed Algorithm 
\\A* Search }
A* is a form of informed Search algorithm, the term “informed” signifies that the algorithm is made aware about the state space in the notion of heuristic function. The search method relies on the finding the amount of match between a node and the goal state. This is quantified using the heuristic function which is basically the difference between the current state from the goal state. The higher value of this function signifies lesser relevancy of that state in reaching towards the goal. The algorithm uses the Breadth-First Search horizontal expansion technique but limits these expansions only to those node who have the smaller heuristic function value and also considers the path cost to the goal. A* performs better in terms of space complexity when compared to DFS  and  improves on the time complexity  when compared to BFS. The only disadvantage of using this algorithm is the computational overhead that is required for calculating the heuristic value along with the path cost of each node that is considered. 
\subsection{Best First Search}
 Best First Search is another algorithm that is very similar in working of A*. The only difference when compared to A* is that the cost of the path is not considered. So its safer to use A* when the problem space requires longer  solution, while the performance is identical for shorter solutions.
\subsection{IDA} 
The Iterative Deepening A* Algorithm works on the short comings of the A*, i.e. resolving the space complexity and keeping the solution optimal at the same time. It follows the DFS approach where the cost of the generated node is matched with a threshold value. If that value is higher, the branch is cut-off from going into further investigation and new states are searched by backtracking of the information. Each iteration recalculates this value in the heuristic function for each level in the tree. The path to the goal state is optimal in the first try and the value is lower than the estimated threshold value.
\subsection{Extended BFS Search Algorithm}

%ref - [2][SOME IMPROVEMENTS OF THE EXTENDED BREADTH-FIRST SEARCH ALGORITHM TAMAS K ´ ADEK AND J ´ ANOS P ´ ANOVICS]


In [2], the authors describe an algorithm that runs on the ESSM ( Extended State-Space Model ) which empowers backtracking capabilities to the algorithms. In EBFS, The States are stored in form of subtrees in the database, with forward functions storing the forward states, forward status, parent and children. The basic idea of storing these trees is to provide extra information to the algorithm in the form of sub-states that are useful for reaching the goal and enables backtracking capability for the problem space.


\section{Problem Definition and Algorithm}
The n-puzzle problem is a classic AI problem which contains n numbered tiles and one blank tile. These plates are arranged in a grid with the numbered tiles marked as 1, 2, 3 .. n. The blank tile is movable in the grid which can be achieved by moving the numbered tiles in the place of empty tile. To achieve the goal state of the puzzle, the grid should be arranged in such a way that the empty tile is at the first position and all the numbered tiles are arranged in numerical order. The problem in solving the n-puzzle is to reach the goal state in as little cost as possible. For instance, an eight-puzzle problem consists of 8 numbered tiles - 1, 2, 3, 4, 5, 6, 7, 8. The goal state of the 8-puzzle problem is shown in the figure. \\
The cost to achieve the goal can be measured in terms of the number of movements done. At any given intermediate state, there can be at least two and at most four possible movements of the blank tile. Although reaching a goal in such puzzles is easy, but finding the shortest path with the lowest cost is difficult. The figure shows an example of a solution for an 8-puzzle problem from the given start state. The state-space of the 8-puzzle problem is such that if the goal state can be achieved in a certain number of steps, then all movements towards the solution are considered good moves and all the movements that are farther from the solution are considered bad moves. The aim is to find the good moves which lead to minimum cost. \\
8-puzzle problem is a search problem which can be solved by various searching algorithms like BFS and DFS. In these, the problems are represented as search graphs or trees. The nodes of the graph/tree denote the states where the goal state is also present as one of the nodes. A part of the tree for the 8-puzzle problem is shown in the figure. The searching can be done by expanding to a depth (child nodes) or exploring the breadth (sibling nodes). \\
For the implementation of BFS and DFS, we referred to the implementation done by [], which used Python. The model of a state was built with parameters like state, parent, cost, depth to maintain information about each state. For the 8-puzzle problem, a state is represented in an array format which shows the arrangement of the numbers in a particular state. For example, state A in the figure is represented as [0,8,7,6,5,4,3,2,1]. An expand() function is also added which is responsible for finding the states obtained after moves. The moves are done in the order of up, down, left and right. The BFS makes use of the queue data structure whereas the DFS makes use of the stack data structure. \\
Additionally, few metrics are used for the measurement of the performance of the search algorithms. The maximum search depth is one of the parameters which measures the maximum depth that the algorithm explores to get the solution. The maximum frontier size is the maximum size of the queue/stack that was acquired for reaching the goal state. Apart from this, running time and maximum RAM usage are other parameters used to measure the efficiency of the algorithm. \\

\subsection{BFS}

\begin{algorithm}[H]
	\SetAlgoLined
	% \KwResult{Write here the result }
	 $queue \gets start state$\;
	 $explored \gets empty$\;
	\While{queue is not empty}{
		node = queue.pop\_left\_state()\;
		explored.add(node)\;
		\If{node is goal state}{
			return queue\;
		}
		neighbors = expand(node)\;
		\For{ each neighbor} {
			\If{neighbor is not explored}{
				queue.append(neighbor)\;
				explored.add(neighbor)\;
			}
		}
	}
	\caption{BFS}
\end{algorithm}

\subsection{DFS}

\begin{algorithm}[H]
	\SetAlgoLined
	% \KwResult{Write here the result }
	$stack \gets start state$\;
	$explored \gets empty$\;
	\While{stack is not empty}{
		node = stack.pop\_state()\;
		explored.add(node)\;
		\If{node is goal state}{
			return stack\;
		}
		neighbors = reverse(expand(node))\;
		\For{ each neighbor} {
			\If{neighbor is not explored}{
				stack.append(neighbor)\;
				explored.add(neighbor)\;
			}
		}
	}
	\caption{DFS}
\end{algorithm}

\section{Experimental Results}
This section should provide the details of the evaluation. Specifically:
\begin{itemize}
\item Methodology: describe the evaluation criteria, the data used during the evaluation, and the methodology followed to perform the evaluation. 
\item Results: present the results of the experimental evaluation. Graphical data and tables are two common ways to present the results. Also, a comparison with a baseline should be provided.
\item Discussion: discuss the implication of the results of the proposed algorithms/models. What are the weakness/strengths of the method(s) compared with the other methods/baseline?
\end{itemize}

\section{Conclusions}
Provide a final discussion of the main results and conclusions of the report. Comment on the lesson learnt and possible improvements.


A standard and well formatted bibliography of papers cited in the report. For example:

\begin{thebibliography}{6}
%

\bibitem {rus}
Russell, Stuart J. (Stuart Jonathan). Artificial Intelligence: a Modern Approach. Upper Saddle River, N.J.       :Prentice Hall, 2010.


\end{thebibliography}
\end{document}
